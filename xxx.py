# -*- coding: utf-8 -*-
"""XXX

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MLCi4yoicfK0YBHwAJ5g2WXNmCX7EzEy
"""

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
from keras.models import Sequential
from keras.layers import Dense, LSTM
from sklearn.preprocessing import MinMaxScaler

st.title('Portfolio Optimization')

# Function to fetch data from Yahoo Finance
def fetch_data(tickers, start, end):
    all_data = pd.DataFrame()
    invalid_tickers = []

    for ticker in tickers:
        try:
            data = yf.download(ticker, start=start, end=end)
            if data.empty:
                invalid_tickers.append(ticker)
            else:
                all_data[ticker] = data['Adj Close']
        except Exception as e:
            st.write(f"Error fetching data for {ticker}: {e}")
            invalid_tickers.append(ticker)

    return all_data, invalid_tickers

# Function to train and evaluate models
def train_and_evaluate_models(X_train, X_test, y_train, y_test):
    models = {
        'Linear Regression': LinearRegression(),
        'Random Forest': RandomForestRegressor(n_estimators=100, random_state=42),
        'LSTM': Sequential([
            LSTM(50, return_sequences=True, input_shape=(X_train.shape[1], X_train.shape[2])),
            LSTM(50, return_sequences=False),
            Dense(25),
            Dense(y_train.shape[1])
        ])
    }

    rmse_scores = {}

    # Linear Regression and Random Forest
    for name, model in models.items():
        if name != 'LSTM':
            model.fit(X_train.reshape(X_train.shape[0], -1), y_train)
            y_pred = model.predict(X_test.reshape(X_test.shape[0], -1))
            rmse = np.sqrt(mean_squared_error(y_test, y_pred))
            rmse_scores[name] = rmse

    # LSTM Model
    X_train_lstm = X_train
    X_test_lstm = X_test
    models['LSTM'].compile(optimizer='adam', loss='mean_squared_error')
    models['LSTM'].fit(X_train_lstm, y_train, epochs=5, batch_size=1, verbose=1)
    y_pred_lstm = models['LSTM'].predict(X_test_lstm)
    rmse_scores['LSTM'] = np.sqrt(mean_squared_error(y_test, y_pred_lstm))

    best_model_name = min(rmse_scores, key=rmse_scores.get)
    best_model = models[best_model_name]

    return best_model, best_model_name, rmse_scores

# Function to simulate portfolios and calculate metrics
def simulate_portfolios(mean_returns, cov_matrix, num_portfolios=10000, risk_free_rate=0.01):
    results = np.zeros((3, num_portfolios))
    weights_record = []

    for i in range(num_portfolios):
        weights = np.random.random(len(mean_returns))
        weights /= np.sum(weights)

        portfolio_return = np.sum(weights * mean_returns) * 252
        portfolio_std_dev = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights))) * np.sqrt(252)
        sharpe_ratio = (portfolio_return - risk_free_rate) / portfolio_std_dev

        results[0, i] = portfolio_return
        results[1, i] = portfolio_std_dev
        results[2, i] = sharpe_ratio
        weights_record.append(weights)

    return results, weights_record

# User input for stock tickers
tickers = st.text_input('Enter stock tickers separated by commas', 'AAPL, MSFT, GOOGL, AMZN')
start_date = st.date_input('Start date', pd.to_datetime('2000-01-01'))
end_date = st.date_input('End date', pd.to_datetime('2023-01-01'))

if st.button('Fetch Data'):
    tickers_list = [ticker.strip() for ticker in tickers.split(',')]
    data, unavailable_tickers = fetch_data(tickers_list, start_date, end_date)

    if unavailable_tickers:
        st.warning(f"The ticker(s) {', '.join(unavailable_tickers)} you entered are not available for analysis.")
    elif data.empty:
        st.warning("No data fetched for the given tickers. Please enter valid tickers.")
    else:
        st.write('Historical Stock Prices:')
        st.line_chart(data)

        # Calculate daily returns
        returns = data.pct_change().dropna()
        if returns.empty:
            st.warning("No returns data available. Please enter valid tickers.")
        else:
            # Summary statistics
            st.write('Summary Statistics:')
            st.write(returns.describe())

            # Plot return distributions
            st.write('Return Distributions:')
            st.area_chart(returns)

            # Correlation matrix
            correlation_matrix = returns.corr()
            st.write('Correlation Matrix:')
            st.write(correlation_matrix)

            # Generate a heatmap of the correlation matrix
            st.write('Correlation Matrix Heatmap:')
            fig, ax = plt.subplots()
            sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5, ax=ax)
            st.pyplot(fig)

            # Portfolio optimization (simplified example)
            st.write('Portfolio Optimization:')
            mean_returns = returns.mean()
            cov_matrix = returns.cov()
            results, weights_record = simulate_portfolios(mean_returns, cov_matrix)

            results_frame = pd.DataFrame(results.T, columns=['Return', 'Standard Deviation', 'Sharpe Ratio'])
            max_sharpe_idx = results_frame['Sharpe Ratio'].idxmax()
            max_sharpe_port = results_frame.iloc[max_sharpe_idx]
            max_sharpe_weights = weights_record[max_sharpe_idx]

            min_vol_idx = results_frame['Standard Deviation'].idxmin()
            min_vol_port = results_frame.iloc[min_vol_idx]
            min_vol_weights = weights_record[min_vol_idx]

            st.write('Maximum Sharpe Ratio Portfolio Allocation:')
            st.write('Annualized Return:', max_sharpe_port[0])
            st.write('Annualized Standard Deviation:', max_sharpe_port[1])
            st.write('Sharpe Ratio:', max_sharpe_port[2])
            st.write('Weights:', max_sharpe_weights)

            st.write('Minimum Volatility Portfolio Allocation:')
            st.write('Annualized Return:', min_vol_port[0])
            st.write('Annualized Standard Deviation:', min_vol_port[1])
            st.write('Sharpe Ratio:', min_vol_port[2])
            st.write('Weights:', min_vol_weights)

            # Plot the efficient frontier
            st.write('Efficient Frontier:')
            fig, ax = plt.subplots()
            scatter = ax.scatter(results_frame['Standard Deviation'], results_frame['Return'], c=results_frame['Sharpe Ratio'], cmap='viridis')
            ax.scatter(max_sharpe_port[1], max_sharpe_port[0], color='r', marker='*', s=200, label='Max Sharpe Ratio')
            ax.scatter(min_vol_port[1], min_vol_port[0], color='b', marker='*', s=200, label='Min Volatility')
            ax.set_title('Efficient Frontier')
            ax.set_xlabel('Annualized Standard Deviation')
            ax.set_ylabel('Annualized Return')
            ax.legend()
            st.pyplot(fig)

            # Train-test split
            X = returns[:-1].values
            y = returns.shift(-1).dropna().values
            X = X.reshape(X.shape[0], X.shape[1], 1)
            y = y.reshape(y.shape[0], y.shape[1])
            X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

            # Train and evaluate models
            best_model, best_model_name, rmse_scores = train_and_evaluate_models(X_train, X_test, y_train, y_test)
            st.write(f"Best model: {best_model_name}")
            st.write(f"RMSE Scores: {rmse_scores}")

            # Make predictions using the best model
            if best_model_name == 'LSTM':
                predicted_returns = pd.Series(best_model.predict(X_test)[-1], index=tickers_list)
            else:
                predicted_returns = pd.Series(best_model.predict(X_test.reshape(X_test.shape[0], -1))[-1], index=tickers_list)

            # Simulate portfolios based on predicted returns
            mean_returns_pred = predicted_returns
            results_pred, weights_record_pred = simulate_portfolios(mean_returns_pred, cov_matrix)

            results_frame_pred = pd.DataFrame(results_pred.T, columns=['Return', 'Standard Deviation', 'Sharpe Ratio'])
            max_sharpe_idx_pred = results_frame_pred['Sharpe Ratio'].idxmax()
            max_sharpe_port_pred = results_frame_pred.iloc[max_sharpe_idx_pred]
            max_sharpe_weights_pred = weights_record_pred[max_sharpe_idx_pred]

            min_vol_idx_pred = results_frame_pred['Standard Deviation'].idxmin()
            min_vol_port_pred = results_frame_pred.iloc[min_vol_idx_pred]
            min_vol_weights_pred = weights_record_pred[min_vol_idx_pred]

            st.write('Predicted Maximum Sharpe Ratio Portfolio Allocation:')
            st.write('Annualized Return:', max_sharpe_port_pred[0])
            st.write('Annualized Standard Deviation:', max_sharpe_port_pred[1])
            st.write('Sharpe Ratio:', max_sharpe_port_pred[2])
            st.write('Weights:', max_sharpe_weights_pred)

            st.write('Predicted Minimum Volatility Portfolio Allocation:')
            st.write('Annualized Return:', min_vol_port_pred[0])
            st.write('Annualized Standard Deviation:', min_vol_port_pred[1])
            st.write('Sharpe Ratio:', min_vol_port_pred[2])
            st.write('Weights:', min_vol_weights_pred)

            # Display weights for historical and predicted minimum volatility portfolio
            min_vol_weights_df = pd.DataFrame({
                'Historical': min_vol_weights,
                'Predicted': min_vol_weights_pred
            }, index=tickers_list)
            st.write("Weights for Minimum Volatility Portfolio:")
            st.write(min_vol_weights_df)

            # Display weights for historical and predicted maximum Sharpe ratio portfolio
            max_sharpe_weights_df = pd.DataFrame({
                'Historical': max_sharpe_weights,
                'Predicted': max_sharpe_weights_pred
            }, index=tickers_list)
            st.write("Weights for Maximum Sharpe Ratio Portfolio:")
            st.write(max_sharpe_weights_df)